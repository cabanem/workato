

# Vector Search `:findNeighbors` (RFC_091325)

## Objective

> Implement a new action that queries a vector index (using the method, `:findNeighbors`) by calling to the index endpoint. 

## Implementation

### Research
- We need to hit: 
```
https://{INDEX_ENDPONT}/v1/projects/{PROJECT_ID}/locations/{LOCATION}/indexEndpoints{INDEX_ENDPOINT_ID}:findNeighbors`
```
- Notes on the host in this context
    - The host is not the standard `REGION-aiplatform.googleapis.com` (this is the regional control-plane host). When querying Vector Search (a data-plane operation), we must call the index endpoint's own domain (i.e., public endpoint domain or PSC DNS/IP).
    - Therefore, the request path carries the **index endpoint**; [the host is the index endpoint's domian].(https://cloud.google.com/vertex-ai/docs/vector-search/query-index-public-endpoint)
- Sources
    - [Vertex AI V1 API - Class Google::Cloud::AIPlatform::V1::FindNeighborsRequest (v1.22.0)](https://cloud.google.com/ruby/docs/reference/google-cloud-ai_platform-v1/latest/Google-Cloud-AIPlatform-V1-FindNeighborsRequest)
    - [Query public index to get nearest neighbors] (https://cloud.google.com/vertex-ai/docs/vector-search/query-index-public-endpoint)
    - [Vertex - crowding and numeric restrict semantics](https://cloud.google.com/vertex-ai/docs/reference/rest/v1/projects.locations.indexes/upsertDatapoints)
    - [Ruby client references](https://cloud.google.com/ruby/docs/reference/google-cloud-ai_platform-v1/latest/Google-Cloud-AIPlatform-V1-FindNeighborsRequest)
    
### Process

#### 1. Create a new action `find_neighbors`

Input

| Name | Required? | Description | Type |
| :--- | :--- | :--- | :--- |
| `index_endpoint_host` | &#9989; | host for the public or PSC index endpoint | `str` |
| `index_endpoint_id` | &#9989; | id for the index endpoint | `str` |
| `deployed_index_id` | &#9989; | id of the deployed index | `str` |
| `queries` | &#9989; | queries supporting | `array` |
| `returnFullDatapoint` | &#10050 | flag | `bool` |

Output
```ruby
nearestNeighbors[] => id,
neighbors[] => distance
datapoint
```

#### 2. Create a new method to build payloads

> Method should:  normalize host, ensure JSOn casing expected by Google's REST

#### 3. Add new object definitions
    - `find_neighbors_input`
    - `find_neighbors_output`

#### 4. Add new picklist for numeric comparison (`numeric_comparison_op`) 

> This should correspond to the numeric restriction ops supported by [IndexDatapoint numeric filters](https://cloud.google.com/vertex-ai/docs/reference/rest/v1/projects.locations.indexes/upsertDatapoints)

```ruby
numeric_comparison_op: lambda do
  %w[EQUAL NOT_EQUAL LESS LESS_EQUAL GREATER GREATER_EQUAL].map { |m| [m.humanize, m] }
end
```
### Design Decisions

1. Override the host in the action

    > Diverging from the other API calls in the connector, Vector Search requires the index endpoint's own host (public/PSC). We want to avoid unexpected global side-effects of this bifurcation, and adhere to Google's [guidance](https://cloud.google.com/vertex-ai/docs/vector-search/query-index-public-endpoint) for public vs PSC routing. 

2. Enforce casing to align with the FindNeighborsRessponse proto

    > In order to align with Google's REST/JSON [mapping of protocol buffers](https://cloud.google.com/nodejs/docs/reference/aiplatform/3.0.0/aiplatform/protos.google.cloud.aiplatform.v1.findneighborsresponse-class), we need to send keys in "camelCase" (e.g., `deployedIndexId`, `neighborCount`, etc.). We enforce this in our method, `payload_for_find_neighbors`. 

3. Support advanced queries

    > The [`:findNeighbors` method](https://cloud.google.com/vertex-ai/docs/reference/rest/v1/projects.locations.indexes/upsertDatapoints) supports [advanced schema](https://cloud.google.com/ruby/docs/reference/google-cloud-ai_platform-v1/0.11.0/Google-Cloud-AIPlatform-V1-IndexDatapoint) (e.g., dense vectors, sparse embeddings, categorical `restricts`, numeric `numericRestricts`, `crowdingTag`). We've tried to extend the action to accept a variety of options to achieve the most reliable outcome. 

4. Surface useful and predictable error content

    > We surface upstream error bodies in `after_error_response` to ensure predictable errors.

